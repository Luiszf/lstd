<html>
<head>
    <!-- jetbrains mono import -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">


    <title> Understanding Spring </title>
    <!-- global styles-->
    <link rel="icon" type="image/x-icon" href="/favicon.png">
    <link rel="stylesheet" type="text/css" href="/lstd/styles.css">
</head>
<body>
    <header>
      <nav>
        <a href="/lstd/">
          <h4>
            Home
          </h4>
        </a>
        <!-- <a href="/br/posts/{translated post}"> -->
        <!--   <h4> -->
        <!--     PT -->
        <!--   </h4> -->
        <!-- </a> -->
      </nav>
      <label id="theme_button_container">
        <input id="theme_button" type="checkbox">
        <span id="theme_icon"></span>
      </label>
    </header>
    <h1>
      Spring
    </h1>
    <h2> Requirements </h2>
    <p> 
      {{ TODO }}
    </p>
    <h2> History </h2>
    <p> 
      {{ TODO }}
    </p>
    <!-- Explain that beans have different meaning in spring/javaBeans/JakartaEE -->
    <h2> Beans </h2>
    <p>
      beans are just plain java objects that are managed by the inversion of control container.
      Note that they are not the same as JavaBeans or Jakarta EE Beans.
    </p>
    <h2> Inversion of Control(IoC) Container </h2>
    <p>
      lets start with the name, why inversion of control? this inversion is about the way we 
      manage objects. Basically in java you normally create a manage the objects(classes) 
      like this:
    </p>
<!-- TODO: work on syntax highlighting -->
<code>
class MyClass { 

  int number;

  public MyClass(int number) {
    this.number = number;
  }
}

public class App {
  public static void main(String[] args) {
    MyClass myClass = new MyClass(0);
  }
}
</code>
    <p>
      nothing new here, you define a class and create an instance of the class and assign it to a variable.
      So, how is that with Inversion of Control.
    </p>
<code>
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Controller;
import org.springframework.stereotype.Component;

@Component
class MyClass { 

  int number;

  public MyClass(int number) {
    this.number = number;
  }
}

@Configuration 
@ComponentScan(basePackageClasses = MyClass.class)
class Config {

  @Bean
  int getNumber() {
    return 0;
  }
}

public class App {
  public static void main(String[] args) {
    ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
    MyClass myClass = context.getBean("myClass", MyClass.class);
  }
}
</code>
    <!-- rewrite this for clarity -->
    <p>
      top to bottom, the Component annotation enables annotation classpath scanning and 
      define it self as a bean. the Configuration annotation signals that the class is 
      a configuration class. the component scan annotation defines the filters that 
      the scan matches with the classes that have classpath scanning available. the bean
      annotation define it self as a bean. ApplicationContext is the central interface to 
      provide configuration for an application, in this case we only use the bean factory
      capabities. AnnotationConfigApplicationContext represents the context of our spring
      Application. the function get bean is from the bean factory Capabilities of the 
      ApplicationContext that is used to instantiate the bean object, MyClass in this case.
    </p>
    <h2> Building </h2>
    <p> 
      {{ TODO }}
    </p>
</body>
</html>
